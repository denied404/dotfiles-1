global !p
# see ~/.vim/pythonx/go.py
import px.go
import re
endglobal

snippet n "func" bw
func $1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet s "type struct" bw
`!p
body = t[2]

type = 'struct'
if re.match("^[A-Z]\w+\(\) \w+", body):
	type = 'interface'
`
type $1 `!p snip.rv=type` {
	$2
}
endsnippet

snippet p "package" "line == 1" bwe
package ${1:`!p snip.rv=px.go.guess_package_name_from_file_name(snip.fn)`}
endsnippet

snippet p "panic" "px.go.is_in_err_condition(buffer, line, column)" bwe
panic(err)
endsnippet

priority -1
snippet i "if" bw
if ${1:`!p snip.rv=px.all.get_last_var_for_snippet()`} {
    ${2:${VISUAL}}
}
endsnippet

snippet i "integer field" "px.go.is_type_declaration(buffer, line)" bwe
$1 int
endsnippet

snippet i "integer field" "px.go.is_func_declaration(buffer, line)" we
$1 int,
endsnippet

snippet s "string field" "px.go.is_type_declaration(buffer, line)" bwe
$1 string
endsnippet

snippet s "string field" "px.go.is_func_declaration(buffer, line)" we
$1 string,
endsnippet

snippet f "float field" "px.go.is_type_declaration(buffer, line)" bwe
$1 float64
endsnippet

snippet f "float field" "px.go.is_func_declaration(buffer, line)" we
$1 float64,
endsnippet

snippet m "map field" "px.go.is_type_declaration(buffer, line)" bwe
$1 map[${2:string}]${3:interface{}}
endsnippet

snippet m "string field" "px.go.is_func_declaration(buffer, line)" we
$1 map[${2:string}]${3:interface{}}$4,
endsnippet

priority -1
snippet ii "if <VISUAL>" bw
if ${VISUAL} {
	$1
}
endsnippet

snippet q "if err != nil" bw
if err != nil {
	return err
}
endsnippet

snippet fe "fmt.Errorf" w
fmt.Errorf($1)
endsnippet

snippet qe "if err != nil" bw
if err != nil {
	return fmt.Errorf("$1: %s", err.Error())
}
endsnippet

snippet qq "if err != nil" bw
if err != nil {
	return ${1:nil}, err
}
endsnippet

snippet qqe "if err != nil" bw
if err != nil {
	return ${1:nil}, fmt.Errorf("$2: %s", err.Error())
}
endsnippet

snippet qp "if err != nil panic" bw
if err != nil {
	panic(err)
}
endsnippet

snippet qn "if ... == nil" bw
if ${1:value} == nil {
	${0:${VISUAL}}
}
endsnippet

snippet r "return" bw
return $1
endsnippet

snippet r "return" "re.match('^\s+if err ', px.util.get_prev_nonempty_line(buffer, line))" eb
return err
endsnippet

snippet fs "... string" bw
$1 string$2
endsnippet

snippet exp "test expected" w
actual := ${1:"Something"}
if actual != ${2:"Actual"} {
	t.Fatalf("unexpected %#v", actual)
}
endsnippet

snippet ,e ", err" i
, err$0
endsnippet

snippet "} e" "else" bw
} else {
	${1:${VISUAL}}
}
endsnippet

snippet co "const" bw
const (
	$1 = $2
)
endsnippet

snippet ci "const iota" w
const (
	${1:CONSTANT} = iota$2
)
endsnippet

snippet ass "anon struct with fields" w
struct {
	$1
}{
	$2
}
endsnippet

snippet "((\w+)\s*(\w+)) js$" "json annotation" br
`!p snip.rv=match.group(1)` \`json:"`!p
	snip.rv=px.all.convert_camelcase_to_snakecase(match.group(2))`"\`
endsnippet

snippet fm "func main" bw
func main() {
	$1
}
endsnippet

snippet fas "anon struct" w
${1:Name} struct {
	$2
}
endsnippet

snippet fi "field int" bw
${1:Name} int
endsnippet

snippet fb "field bool" bw
${1:Name} bool
endsnippet

snippet mp "map" w
map[${1:string}]${2:interface}
endsnippet

snippet msi "map[string]interface" w
map[string]interface{}
endsnippet

snippet sw "switch" bw
switch ${1:name} {
case ${2:true}:
	$3
$4
}
endsnippet

snippet swt "switch true" bw
switch {
case ${1}:
	$2
$3
}
endsnippet

snippet f "for range" bw
for ${1:_}, ${2:val} := range ${3:Slice} {
	${4:${VISUAL}}
}
endsnippet

snippet pr "log.Printf(%#v" bw
log.Printf("%#v", $1)
endsnippet

snippet play "package main" bw
package main

import "fmt"

func main() {
	$0
}
endsnippet

snippet omit "omit section" w
// OMIT
${0:${VISUAL}}
// END OMIT
endsnippet

snippet af "anon func" iw
func($1) $2{
	${0:${VISUAL}}
}
endsnippet

snippet vr "var" bw
var (
	$1
)
endsnippet

snippet cs "case" bw
case $1:
	$2
endsnippet

snippet rn "return nil" bw
return nil
endsnippet

snippet ap "append" bw
${1:slice} = append($1, $2)
endsnippet

snippet ms "make slice" w
make([]$1, ${2:0})
endsnippet

snippet mc "make chan" w
make(chan $1, ${2:0})
endsnippet

snippet mm "make map" w
make(map[${1:string}]${2:interface\{\}})
endsnippet

snippet nn "!= nil" w
${1:${VISUAL}} != nil
endsnippet

snippet if "interface" w
interface{}
endsnippet

snippet ts "type switch" bw
switch ${1:newVar} := ${2:checkVar}.(type) {
case ${3:Type}:
	$4
}
endsnippet

snippet ,n ", nil"
, nil
endsnippet

snippet n, ", nil"
nil,
endsnippet

snippet frr "forever" bw
for {
	$1
}
endsnippet

snippet ae "blah, err := " bw
${1:data}, err :=
endsnippet

snippet a "blah := " bw
${1:data} :=
endsnippet


snippet qt "t.fatal" bw
if err != nil {
	t.Fatal(err)
}
endsnippet

snippet qr "fmt errorf" bw
if err != nil {
	fmt.Errorf(err.Error())
	os.Exit(1)
}
endsnippet

snippet qf "log fatal" bw
if err != nil {
	log.Fatal(err.Error())
}
endsnippet

snippet qff "log fatalf" bw
if err != nil {
	log.Fatalf(\`$1: %s\`, $2, err)
}
endsnippet

snippet rt "return true" bw
return true
endsnippet

snippet rf "return false" bw
return false
endsnippet

snippet d "define method" bw
`!p
buffer, line = px.all.get_buffer_line()

opening = '('
closing = ')'

if len(buffer[line - 1]) > 80 or not re.search('^func \(', buffer[line - 1]):
	opening = '(\n\t'
	closing = '\n)'

`func (`!p snip.rv=' '.join(px.go.extract_prev_method_binding_for_cursor())`) $1`!p snip.rv=opening`$2`!p snip.rv=closing` $3${3/.+/ /}{
	$5
}
endsnippet

snippet dp "define method on pointer" bw
`!p
buffer, line = px.all.get_buffer_line()

opening = '('
closing = ')'

if len(buffer[line - 1]) > 80 or not re.search('^func \(', buffer[line - 1]):
	opening = '(\n\t'
	closing = '\n)'

`func (`!p snip.rv=' *'.join(px.go.extract_prev_method_binding_for_cursor())`) $1`!p snip.rv=opening`$2`!p snip.rv=closing` $3${3/.+/ /}{
	$5
}
endsnippet

snippet re "return errors.New" bw
return errors.New($1)
endsnippet

snippet y "error" w
error
endsnippet

snippet lf "log.Printf" w
log.Printf($1)
endsnippet

snippet td "todo" bw
// @TODO:
endsnippet

snippet l "last slice usage" iw
${1:`!p snip.rv=px.go.get_previous_slice_usage()`}[$2]
endsnippet

snippet "(func\s.*\)\s+)([\w\d_\s\{\}\[\]\*\.]+),\s?([\w\d_\s\{\}\[\]\*\.]+)" "return multiple" r
`!p snip.rv=match.group(1)`(`!p snip.rv=match.group(2)`, `!p snip.rv=match.group(3)`)
endsnippet

snippet for "for loop" bw
for $1 {
    $2
}
endsnippet

snippet fp "fmt.Println" w
fmt.Println($1)
endsnippet

snippet e "fmt.Printf" bw
fmt.Printf("`!p snip.rv=t[1]`: %v\n", $1)
endsnippet

snippet ej "print json" bw
`!p
from random import randint

name = t[1] + str(randint(10, 9999))
`ej`!p snip.rv=name`, _ := json.MarshalIndent($1, "", "  ")
fmt.Printf("`!p snip.rv=t[1]`: %s\n", string(ej`!p snip.rv=name`))
endsnippet

snippet te "func Test" bw
func Test$1(t *testing.T) {
	$2
}
endsnippet

snippet i "if err != nil" "re.match('^\s+[^=]*err\s*:?=', buffer[line-2])" e
if err != nil {
	$1
}
endsnippet

snippet , "return ... , nil" "px.go.is_return_argument(buffer, line, column)" ie
, `!p if px.go.is_in_err_condition(vim.current.buffer, vim.current.window.cursor[0], vim.current.window.cursor[1]):
	snip.rv = "err"
else:
	snip.rv = "nil"`
endsnippet
