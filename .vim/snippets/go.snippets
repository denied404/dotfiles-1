global !p
import re
import os.path
import vim

import px
for full_name, name in px.libs().items():
    exec("import " + full_name)
endglobal


context "snip.context=snip"
snippet e "" bwe
`!p
left = " "
right="()"
right = right[10]
if "\n" in t[1]:
	tabs = snip.context.column-1
	left = " func(){"
	right = "\n"+(tabs*"\t")+"}()"
`defer`!p snip.rv=left`$1`!p snip.rv=right`
endsnippet

snippet (s "(string" i
(string
endsnippet

snippet ([]s "([]string" i
([]string
endsnippet

snippet (b "(bool" i
(bool
endsnippet

snippet (i "(int" i
(int
endsnippet

#context "px.util.match_higher_indent(snip.buffer, (snip.line, 0), '^var \(')"
#snippet a "" wbe
#$1 = args["$2"].($3)
#$0
#endsnippet

snippet a "arg" w
args["$1"].($2)
endsnippet

snippet dcp "docopt" w
args := godocs.MustParse(usage, version, godocs.UsePager)
endsnippet

snippet f "false" w
false
endsnippet

snippet t "true" w
true
endsnippet

snippet te "assert.Equal" wb
test.Equal($1, $2)
endsnippet

snippet pt "print trace" wb
{`!p
if t[1] == "0":
	snip.rv="\n\t\tprintln(\`========================XXXXXX\`)\n\t"
else:
	snip.rv=''
`	_, file, line, _ := runtime.Caller(${1:0})
	print("stack #$1: ", file, ":", line, "\n")
}
$0
endsnippet

snippet ptf "print trace" wb
{
	println("================================================================")
	println("stack trace:")
	step := 0
	for {
		_, file, line, ok := runtime.Caller(step)
		if !ok {
			println("end of stack")
			break
		}
		println("stack #", step, ": ", file, ":", line)
		step++
	}
}
$0
endsnippet

snippet m "map[whatever]whatever" w
map[${1:string}]${2:interface\{\}}
endsnippet

snippet ms "map[string]whatever" w
map[string]${1:interface\{\}}
endsnippet

snippet mss "map[string]string" w
map[string]string
endsnippet

snippet "map\[(\w+)\]i" "map[\w]interface{}" r
map[`!p snip.rv=match.group(1)`]interface{}$0
endsnippet

snippet []s "[]string" w
[]string{$1}$0
endsnippet

snippet c "construct structure" w
$2 = $1{
	$3,
}
endsnippet


priority 10
snippet "= c" "construct structure"
= $1{
	$2,
}
endsnippet

snippet xvu "usage" w
var (
    version = "[manual build]"
    usage = "$1 " + version + \`
$2

Usage:
    $1 [options]
    $1 -h | --help
    $1 --version

Options:
    $3
    -h --help		Show this screen.
    --version       Show version.
\`
)
endsnippet

snippet he "" w
ser.Errorf(err, "$1"${2/(.+)/, /}$2)
endsnippet

snippet dd "" w
p.parseMethodStmt(receiver, $1)
endsnippet

# logger
snippet xlo "" wb
package main

import (
	"fmt"
	"strings"

	"github.com/kovetskiy/lorg"
)

func fatalf(format string, values ...interface{}) {
	logger.Fatalf(format, values...)
}

func errorf(format string, values ...interface{}) {
	logger.Errorf(format, values...)
}

func warningf(format string, values ...interface{}) {
	logger.Warningf(format, values...)
}

func infof(format string, values ...interface{}) {
	logger.Infof(format, values...)
}

func debugf(format string, values ...interface{}) {
	logger.Debugf(format, values...)
}

func tracef(format string, values ...interface{}) {
	logger.Tracef(format, values...)
}

func debugln(value interface{}) {
	logger.Debug(value)
}

func infoln(value interface{}) {
	logger.Info(value)
}

func fatalln(value interface{}) {
	logger.Fatal(value)
}

func errorln(value interface{}) {
	logger.Error(value)
}

func fatalh(err error, format string, args ...interface{}) {
	logger.Fatal(hierr.Errorf(err, format, args...))
}

func warningh(err error, format string, args ...interface{}) {
	logger.Warning(hierr.Errorf(err, format, args...))
}

func errorh(err error, format string, args ...interface{}) {
	logger.Error(hierr.Errorf(err, format, args...))
}
endsnippet

# hierr.Errorf
snippet hh "" wA
hierr.Errorf(
    ${1:err}, "$2",
)$0
endsnippet

snippet hp "" w
hierr.Push(
    hierr.Errorf(
        $1,$2
    ),
    $3,
)
endsnippet

# hierr.Fatalf
snippet hf "" wA
hierr.Fatalf(
    ${1:err}, $2,
)$0
endsnippet

snippet kkd "" wA
debugf("$1", $2)
endsnippet

snippet kki "" wA
infof("$1", $2)
endsnippet

snippet kke "" wA
errorln($1)
endsnippet

snippet kkf "" wA
fatalln("$1")
endsnippet

snippet kkh "" wA
errorh(
    err, "$1", $2
)
endsnippet

#global !p
#def context_bracket_expanding(snip):
    #line = px.buffer.get()[px.cursor.get()[0]]
    #matches = re.match(r'^\s+([\)\}\]])', line)
    #if matches:
        #return True
    #return False
#endglobal


#context "context_bracket_expanding(snip)"
#snippet "^(\s+)$" "" rAe
#`!p snip.rv=match.group(1)+"\t"`$1`!p
#if len(t[1]) > 0:
    #snip.rv=","
#else:
    #snip.rv=""
#`$0
#`!p snip.rv=match.group(1)`
#endsnippet

snippet ko "" w
import "github.com/kovetskiy/ko"

type config struct {
	Web struct {
		Listen string \`toml:"listen"\`
	} \`toml:"web"\`

	Database struct {
		URL string \`toml:"url"\`
	} \`toml:"database"\`
}

func getConfig(path string) (*config, error) {
	config := &config{}
	err := ko.Load(path, config)
	if err != nil {
		return nil, err
	}

	return config, nil
}
endsnippet

snippet va "" w
var (
    $1
)
endsnippet

global !p
def is_inside_var(snip):
    return px.whitespaces.match_higher_indent(
        snip.buffer, snip.cursor, 'var \($'
    )
endglobal

context "is_inside_var(snip)"
snippet "^(\s+)a" "" wre
`!p snip.rv=match.group(1)`$1 = args["$2"].($3)
endsnippet

snippet req "" w
required:"true"
endsnippet

priority 200
snippet "^(func.*)\(cgc" "" Air
`!p snip.rv=match.group(1)`(context *gin.Context
endsnippet

priority 100
snippet (cgc "" Ai
(context
endsnippet

snippet cgc "" i
context
endsnippet

snippet xli "" w
func listen(address string, router *gin.Engine) error {
	addr, err := net.ResolveTCPAddr("tcp", address)
	if err != nil {
		return hierr.Errorf(
			err,
			"can't resolve '%s'", address,
		)
	}

	socket, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return hierr.Errorf(
			err,
			"can't listen '%s'", addr,
		)
	}

	infof("listening at %s", address)

	return http.Serve(socket, router)
}
endsnippet

snippet xvl "" w
var (
	logger    = lorg.NewLog()
	debugMode = false
	traceMode = false
)
endsnippet

snippet xml "" w
logger.SetFormat(
    colorgful.MustApplyDefaultTheme(
        "${time} ${level:[%s]:right:short} ${prefix}%s",
        colorgful.Dark,
    ),
)

debugMode = args["--debug"].(bool)
if debugMode {
    logger.SetLevel(lorg.LevelDebug)
}

traceMode = args["--trace"].(bool)
if traceMode {
    logger.SetLevel(lorg.LevelTrace)
}

endsnippet

snippet kf "" wA
fatalh(err, "$1", $2)
endsnippet

snippet epu "" wA
push(context, "${1:errors}", $2)
endsnippet

snippet ere "" wA
api.render(context, "${1:}")
return
endsnippet

snippet erd "" wA
context.Redirect(http.Status${1:Found}, "/$2")
return
endsnippet

snippet eva "" wA
\`validate:"${1:required}"\`
endsnippet
