global !p
import re
import os.path
import vim

import px
for full_name, name in px.libs().items():
    exec "import " + full_name
    exec "import " + full_name + " as " + name
endglobal


context "snip.context=snip"
snippet e "" bwe
`!p
left = " "
right="()"
right = right[10]
if "\n" in t[1]:
	tabs = snip.context.column-1
	left = " func(){"
	right = "\n"+(tabs*"\t")+"}()"
`defer`!p snip.rv=left`$1`!p snip.rv=right`
endsnippet

snippet (s "(string" i
(string
endsnippet

snippet ([]s "([]string" i
([]string
endsnippet

snippet (b "(bool" i
(bool
endsnippet

snippet (i "(int" i
(int
endsnippet

#context "px.util.match_higher_indent(snip.buffer, (snip.line, 0), '^var \(')"
#snippet a "" wbe
#$1 = args["$2"].($3)
#$0
#endsnippet

snippet a "arg" w
args["$1"].($2)
endsnippet

snippet dcp "docopt" w
args := godocs.MustParse(usage, version, godocs.UsePager)
endsnippet

snippet f "false" w
false
endsnippet

snippet t "true" w
true
endsnippet

snippet te "assert.Equal" wb
test.Equal($1, $2)
endsnippet

snippet pt "print trace" wb
{`!p
if t[1] == "0":
	snip.rv="\n\t\tprintln(\`========================XXXXXX\`)\n\t"
else:
	snip.rv=''
`	_, file, line, _ := runtime.Caller(${1:0})
	print("stack #$1: ", file, ":", line, "\n")
}
$0
endsnippet

snippet ptf "print trace" wb
{
	println("================================================================")
	println("stack trace:")
	step := 0
	for {
		_, file, line, ok := runtime.Caller(step)
		if !ok {
			println("end of stack")
			break
		}
		println("stack #", step, ": ", file, ":", line)
		step++
	}
}
$0
endsnippet

snippet m "map[whatever]whatever" w
map[${1:string}]${2:interface\{\}}
endsnippet

snippet ms "map[string]whatever" w
map[string]${1:interface\{\}}
endsnippet

snippet mss "map[string]string" w
map[string]string
endsnippet

snippet "map\[(\w+)\]i" "map[\w]interface{}" r
map[`!p snip.rv=match.group(1)`]interface{}$0
endsnippet

snippet []s "[]string" w
[]string{$1}$0
endsnippet

snippet c "construct structure" w
$2 = $1{
	$3,
}
endsnippet


priority 10
snippet "= c" "construct structure"
= $1{
	$2,
}
endsnippet

snippet u "usage" w
version = "1.0"
usage = \`$1 \` + version + \`
$2

Usage:
	$1 $3
	$1 -h | --help
	$1 --version

Options:
	-h --help		Show this screen.
	--version       Show version.
\`
endsnippet

snippet he "" w
hierr.Errorf(err, "$1"${2/(.+)/, /}$2)
endsnippet

snippet dd "" w
p.parseMethodStmt(receiver, $1)
endsnippet

# logger
snippet lo "" wb
package main

import (
	"fmt"
	"strings"

	"github.com/kovetskiy/lorg"
)

const logFormat = `${level:%s\::right:false} ${time} %s`

func getLogger() lorg.Logger {
	logger := lorg.NewLog()
	logger.SetFormat(lorg.NewFormat(logFormat))
	logger.SetLevel(lorg.LevelDebug)

	return logger
}

func fatalf(format string, values ...interface{}) {
	logger.Fatal(wrapNewLines(format, values...))
}

func errorf(format string, values ...interface{}) {
	logger.Error(wrapNewLines(format, values...))
}

func warningf(format string, values ...interface{}) {
	logger.Warning(wrapNewLines(format, values...))
}

func infof(format string, values ...interface{}) {
	logger.Info(wrapNewLines(format, values...))
}

func debugf(format string, values ...interface{}) {
	logger.Debug(wrapNewLines(format, values...))
}

func tracef(format string, values ...interface{}) {
	logger.Trace(wrapNewLines(format, values...))
}

func debugln(value interface{}) {
	logger.Debug(wrapNewLines("%s", value))
}

func infoln(value interface{}) {
	logger.Info(wrapNewLines("%s", value))
}

func fatalln(value interface{}) {
	logger.Fatal(wrapNewLines("%s", value))
}

func errorln(value interface{}) {
	logger.Error(wrapNewLines("%s", value))
}

func wrapNewLines(format string, values ...interface{}) string {
	contents := fmt.Sprintf(format, values...)
	contents = strings.TrimSuffix(contents, "\n")
	contents = strings.Replace(
		contents,
		"\n",
		"\n"+strings.Repeat(" ", loggerFormattinbBasicLength),
		-1,
	)

	return contents
}
endsnippet

# hierr.Errorf
snippet hh "" wA
hierr.Errorf(
    ${1:err},
    $2,
)$0
endsnippet

snippet hp "" w
hierr.Push(
    hierr.Errorf(
        $1,$2
    ),
    $3,
)
endsnippet

# hierr.Fatalf
snippet hf "" wA
hierr.Fatalf(
    ${1:err},
    $2,
)$0
endsnippet

post_jump "px.snippets.expand(snip)"
snippet kkd "" wA
ldebug$1
endsnippet

post_jump "px.snippets.expan(snip)"
snippet kkl "" wA
linfo$1
endsnippet

post_jump "px.snippets.expand(snip)"
snippet kke "" wA
lerror$1
endsnippet

post_jump "px.snippets.expand(snip)"
snippet kkf "" wA
lfatal$1
endsnippet

snippet "^(\s+)l(debug|info|error|fatal)" "" wr
`!p

try:
    once
    line = px.buffer.get()[line_number].replace("\t", "    ")
    if not breakline and len(line) > 79:
        breakline = True
except:
    once = True
    line_number = px.cursor.get()[0]
    breakline = False


func    = match.group(2)+"ln"
content = t[1]
left    = '('
right   = ''
separator = ')'

if "," in t[2] or "\n" in t[2] or "\n" in t[1]:
    breakline = True

if breakline:
    left = '(\n' + match.group(1)
    separator = ',\n' + match.group(1) + ')'
if re.search('^\w+ ', content) or re.search('%', content):
    func = match.group(2)+"f"
    left = '("'
    right = ')'
    if breakline:
        left = '(\n' + match.group(1) + "\t" + '"'
        right = '\n' + match.group(1) + ')'
    separator='"'
    if t[2] != "":
        separator = '", '
        if breakline:
            separator = '",\n' + match.group(1) + "\t"

snip.rv=match.group(1)
``!p snip.rv=func``!p snip.rv=left`$1`!p snip.rv=separator`$2`!p snip.rv=right`
endsnippet

#global !p
#def context_bracket_expanding(snip):
    #line = px.buffer.get()[px.cursor.get()[0]]
    #matches = re.match(r'^\s+([\)\}\]])', line)
    #if matches:
        #return True
    #return False
#endglobal


#context "context_bracket_expanding(snip)"
#snippet "^(\s+)$" "" rAe
#`!p snip.rv=match.group(1)+"\t"`$1`!p
#if len(t[1]) > 0:
    #snip.rv=","
#else:
    #snip.rv=""
#`$0
#`!p snip.rv=match.group(1)`
#endsnippet
